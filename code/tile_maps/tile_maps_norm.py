import sys
import numpy as np
import healpy as hp
from scipy.stats import median_absolute_deviation as mad


def good_maps(raw_tile):
    '''Here, we extract "good satellie" data from the tile_maps_raw 
    generated by tile_maps.py. We also normalize the maps by
    the reference beam'''

    f_name, _ = raw_tile.name.split('.')
    tile, ref, _, _ = f_name.split('_')
    
    # Load reference FEE model
    ref_fee_model = np.load(ref_model, allow_pickle=True)
    if 'XX' in tile:
        ref_fee = ref_fee_model['XX']
    else:
        ref_fee = ref_fee_model['YY']
   
    # load data from map .npz file
    tile_data   = np.load(raw_tile, allow_pickle=True)
    tile_data   = {key:tile_data[key].item() for key in tile_data}
    ref_map     = tile_data['ref_map'] 
    tile_map    = tile_data['tile_map']  
    
    
    for p in pointings:
        
        # Good empty maps

        # This contains the data from all the good sat ref data
        ref_map_good = [[] for pixel in range(hp.nside2npix(nside))]
        
        # This contains the data from all the good sat ref data
        tile_map_good = [[] for pixel in range(hp.nside2npix(nside))]
        
        for sat in good_sats:

            for pix in range(hp.nside2npix(nside)):

                ref_map_good[pix].extend(ref_map[p][sat][pix])
                tile_map_good[pix].extend(tile_map[p][sat][pix])
        
        # Here, we divide tile power by ref power in log space
        ratio_map_good = [[] for pixel in range(hp.nside2npix(nside))]
        for i in range(len(tile_map_good)):
            ratio_map_good.extend(np.subtract(tile_map_good[i], ref_map_good[i]))

        ratio_map_med = [np.nanmedian(i) if len(i) > 0 else np.nan for i in ratio_map_good]
        
        ratio_map_mad = [mad(i) if len(i) > 0 else np.nan for i in ratio_map_good]

        # Final tile map. Ratio map normalized by fee ref beam model
        tile_map_norm = np.add(ratio_map_med, ref_fee)

        print('Yelp')

if __name__=='__main__':
    
    import argparse
    import matplotlib
    matplotlib.use('Agg')
    from pathlib import Path
    import concurrent.futures
    import matplotlib.pyplot as plt
    

    parser = argparse.ArgumentParser(description="""
        Plot healpix map of reference data
        """)
    
    parser.add_argument('--out_dir', metavar='\b', default='./../../outputs/tile_maps/',
            help='Output directory. Default=./../../outputs/tile_maps/')
    parser.add_argument('--map_dir', metavar='\b', default='./../../outputs/tile_maps/tile_maps_raw',
            help='Output directory. Default=./../../outputs/tile_maps/tile_maps_raw')
    parser.add_argument('--ref_model', metavar='\b', default='../../outputs/reproject_ref/ref_dipole_models.npz',
            help='Healpix reference FEE model file. default=../../outputs/reproject_ref/ref_dipole_models.npz')
    parser.add_argument('--nside', metavar='\b', type=int,  default=32,help='Healpix Nside. Default = 32')
    
    args = parser.parse_args()
    
    out_dir     = Path(args.out_dir)
    map_dir     = Path(args.map_dir)
    ref_model   = Path(args.ref_model)
    nside       = args.nside
    
    # Good sats from which to make plots
    good_sats = [
            25338, 25984, 25985,
            28654, 40086, 40087,
            40091, 41179, 41180,
            41182, 41183, 41184,
            41185, 41187, 41188,
            41189, 44387
            ]
    
    # list of beam pointings
    pointings = ['0','2','4']
    
    map_files = [item for item in map_dir.glob('*.npz')]

    # Parallization magic happens here
    #with concurrent.futures.ProcessPoolExecutor() as executor:
    #    results = executor.map(good_maps, map_files)

    good_maps(map_files[0])






